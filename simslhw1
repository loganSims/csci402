#lang racket
;;;;;;;;;;;;;;;;;;;;
;;Logan Sims
;;CSCI 402
;;Summer 2015     
;;
;;
;;
;;
;;;;;;;;;;;;;;;;;;;;

(define node% 
  (class object%
    (init b)               
  
    (define board b)
    (define minmax -1)
    (define children '()) 
    
    
    (define/public (get-board)
    board)
    
    (define/public (get-minmax)
    minmax)
    
    (define/public (get-children)
    children)
    
    (define/public (set-children c)
    (set! children c))   
    
    (define/public (set-board newboard)
    (set! board newboard))
    
    (define/public (set-minmax value)
    (set! minmax value))
     
    (super-new)))

;(define charlie (new node% (b 10)))

(define gameboard '())
(define turn 0)

;checks for a winner
(define check-winner
   (lambda (gameboard player)
     (define game-on #f)
     (for ((i gameboard))
           (cond ((> i 2)
                  (set! game-on #t))))
     game-on))

;flips turns between player 0 and 1
(define change-turn
  (lambda (turn)
    (cond ((= turn 1)
           0)
          ((= turn 0)
           1))))

(define minimaxDFS
  (lambda (node turn)

    (define leaf #t)
    (define min-value 2)
    (define max-value -2)
    
    (for ((child (send node get-children)))
      (set! leaf #f)
      (minimaxDFS child (change-turn turn)))
    
    (cond (leaf
          (cond ((= turn 1) ;max wins at this leaf
                 (send node set-minmax 0))
                (else ;min wins at this leaf
                 (send node set-minmax 1))))
          (else ;set minmax value to min/max of child depending on turn
           (for ((child (send node get-children)))
             (cond ((= turn 1) ;max wins at this leaf
                 (set! max-value (max max-value (send child get-minmax)))
                 (send node set-minmax max-value))
                (else ;min wins at this leaf
                 (set! min-value (min min-value (send child get-minmax)))
                 (send node set-minmax min-value))))))))
    

(define build-tree
  (lambda (game)
  ;set root to node with gameboard = size
    (define root (new node% (b (list game))))
    (define tree (get-children root))
    tree))
    
(define get-children
  (lambda (parent)
    
    (define test-board (remove-duplicates (send parent get-board)))
    (define children '())
    (define has-children #f)
    
    (for ((i test-board))
      (cond ((> i 2) ;this pile can be split to make new gameboards (nodes)
             (set! has-children #t)
             (define moves (range 1 (ceiling (/ i 2)) )) 
             (for ((j moves))
               (define child (new node% (b (send parent get-board))))
               ;perform move on test nodes.
               (send child set-board (remove i (send child get-board)))
               (send child set-board (append (send child get-board) (list j (- i j)) ))  

               (set! child (get-children child))
               (set! children (append (list child) children))))))
    
    (cond(has-children
          (send parent set-children children)))
    parent))


;sets up the gameboard 
(define set-up
  (lambda (coins)
    (list coins)
    ))

;Gets and validates a move from a player.
(define get-move
  (lambda (gameboard)
    (displayln "Make a move. (ex. [pile] [sub-pile 1] [sub-pile 2])")
    (define getting-move #t)
    (let loop ()
      (when getting-move
        (define move (read-line))
        (define movelst (string-split move))
        
        (cond ((and (and (member (string->number (car movelst)) gameboard) 
                         (equal? 3 (length movelst)))
                    (and (not (equal? (string->number (third movelst))(string->number(second movelst)))) 
                         (equal? (+(string->number(second movelst))(string->number(third movelst))) 
                                 (string->number(car movelst)))))
               
               (set! gameboard (remove (string->number (car movelst)) gameboard))
               (set! gameboard (append (list (string->number(second movelst))(string->number(third movelst))) gameboard))
               (set! getting-move #f))
              ((equal? move "show") (displayln gameboard))
              (else  (displayln "please enter a correct move. (ex. [pile] [split 1] [split 2])")))
        (loop)))
    gameboard))
    
;Main function
(define Nim
  (lambda (x)
    (set! gameboard (set-up x))
    (let loop ()
      (displayln gameboard)
      (when (check-winner gameboard turn)
        (set! turn (change-turn turn))
        (cond ((= turn 0)
               (begin
               (displayln "computer turn")
               ;(set! gameboard (make-move gameboard turn turn))
               (set! gameboard (remove (car gameboard) gameboard))
               ))
              ((= turn 1)
               (begin
               (set! gameboard (get-move gameboard)))))
        (loop)))
(cond ((= turn 0)
       (displayln "Computer Wins!"))
      (else
       (displayln "Player Wins!")))))

;(Nim 7)
(define root (build-tree 7))
(minimaxDFS root 0)
(displayln (send root get-board))
(displayln (send root get-minmax))

    (for ((child (send root get-children)))
      (displayln (send child get-board))
      (displayln (send child get-minmax))
      (for ((c (send child get-children)))
              (displayln (send c get-board))
        (displayln (send c get-minmax))
      (for ((d (send c get-children)))
              (displayln (send d get-board))
        (displayln (send d get-minmax)))))