#lang racket
;;;;;;;;;;;;;;;;;;;;
;;Logan Sims
;;CSCI 402
;;Summer 2015     
;;
;;
;;
;;
;;;;;;;;;;;;;;;;;;;;

(define gameboard '())
(define turn 0)

;checks for a winner
(define check-winner
   (lambda (gameboard player)
     (define game-on #f)
     (for ((i gameboard))
           (cond ((> i 2)
                  (set! game-on #t))))
     game-on))

;flips turns between player 0 and 1
(define change-turn
  (lambda (turn)
    (cond ((= turn 1)
           0)
          ((= turn 0)
           1))))

; Uses min max alg to find best move
; Explores all possible routes of gameflow,
; once it finds a move that can lead to a winning move
; it will take it. 
;
; Keeps track of who wins at a leaf by attaching that player
; to the gameboard set up that got the algorithm to that leaf.
; This why the algorithm can keep track of what moves lead where.
;
; Returns a gameboard with the car set to what player will
; win in the move. This will need to be removed to set the
; gameboard to the computers move
;
(define make-move
  (lambda (gameboard me turn)
    (define winning-move '())
    (define another-move gameboard)
    (define test-board1 (remove-duplicates gameboard))
    (define test-board2 gameboard)
    (define moves '())
    (define cant-make-move #t) ;used for base case of recurison
    
    (for ((i test-board1))
          (cond ((> i 2)
                 (set! cant-make-move #f)
                 ;set of moves that can be made with i
                 (set! moves (range 1 (ceiling (/ i 2)) )) 
                 (for ((j moves))
                       ;perform hypothetical move and see where it leads.
                       (set! test-board2 gameboard)
                       (set! test-board2 (remove i test-board2))
                       (set! test-board2 (append test-board2 (list j (- i j))))
                       (cond ((null? winning-move)
                              (set! winning-move (append (list turn) test-board2))))
                       (set! another-move (make-move test-board2 me (change-turn turn)))
                   
                       ;applies min/max logic to determin which move is a winning move
                       (cond ((= turn 1)
                              (cond ((> (car another-move) (car winning-move))
                                     (set! winning-move (append (list turn) test-board2)))))
                             ((= turn 0)
                              (cond ((< (car another-move) (car winning-move))
                                     (set! winning-move (append (list turn) test-board2))))))))))
    ;base case: end of a hypothetical game, 
    ;see who won and what the game looked like and return the 
    ;winner and gameboard with the winner as the car of the board
    (cond (cant-make-move 
           (append (list (change-turn turn)) gameboard)) ;return winner appended to gameboard
          (else
           winning-move))))

;sets up the gameboard 
(define set-up
  (lambda (coins)
    (list coins)
    ))

;Gets and validates a move from a player.
(define get-move
  (lambda (gameboard)
    (displayln "Make a move. (ex. [pile] [sub-pile 1] [sub-pile 2])")
    (define getting-move #t)
    (let loop ()
      (when getting-move
        (define move (read-line))
        (define movelst (string-split move))
        
        (cond ((and (and (member (string->number (car movelst)) gameboard) 
                         (equal? 3 (length movelst)))
                    (and (not (equal? (string->number (third movelst))(string->number(second movelst)))) 
                         (equal? (+(string->number(second movelst))(string->number(third movelst))) 
                                 (string->number(car movelst)))))
               
               (set! gameboard (remove (string->number (car movelst)) gameboard))
               (set! gameboard (append (list (string->number(second movelst))(string->number(third movelst))) gameboard))
               (set! getting-move #f))
              ((equal? move "show") (displayln gameboard))
              (else  (displayln "please enter a correct move. (ex. [pile] [split 1] [split 2])")))
        (loop)))
    gameboard))
    
;Main function
(define Nim
  (lambda (x)
    (set! gameboard (set-up x))
    (let loop ()
      (displayln gameboard)
      (when (check-winner gameboard turn)
        (set! turn (change-turn turn))
        (cond ((= turn 0)
               (begin
               (displayln "computer turn")
               (set! gameboard (make-move gameboard turn turn))
               (set! gameboard (remove (car gameboard) gameboard))
               ))
              ((= turn 1)
               (begin
               (set! gameboard (get-move gameboard)))))
        (loop)))
(cond ((= turn 0)
       (displayln "Computer Wins!"))
      (else
       (displayln "Player Wins!")))))

(Nim 7)